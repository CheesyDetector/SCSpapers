
## 现存问题
- 智能合约验证（合约源码验证/字节码验证）是指将一个地址上存的字节码与用户提供源码的编译结果对应
- 以太坊智能合约验证通过区块链浏览器Etherscan和Blockscout，还有官方平台Sourcify
- 目前验证器的可信赖程度和安全性都得不到保障

## 贡献
- 第一个总结以太坊智能合约验证服务的设计和实现
- 在验证服务中发现了8个被忽视但可被利用的漏洞类型
- 提出了检测、利用和缓解这些类型漏洞的具体方法，并揭示了隐藏在三个验证器中的19个漏洞。截至撰写本文时，已确认15个漏洞，其中10个已及时修补
- 未发现的漏洞可能会对以太坊生态系统产生极端的负面影响。如数以千万的合约会被攻击者滥用，数以百计的合约已经被操纵了

## 核心部分
### 攻击模型
1. 敌对验证（A1）-对应漏洞1~3
   
   利用验证器的漏洞，构造虚假的合约源码，在其他人部署合约字节码完成验证
2. 源欺骗（A2）-对应漏洞4~8
   
   攻击者也为合约部署者，但是故意提供虚假的源码完成验证
   
### 验证架构
1. 不可信源码数据采集模块（M1）
   
   源代码文件（有可能有多个文件，Solidity编译器solc允许多个源码文件和路径打包进一个JSON文件），配置项，一个地址
2. 链上数据采集模块（M2）
   
   根据M1中的地址，获取Runtime Code或Bytecode（Bytecode包括Runtime Code和Constructor Code）
3. 编译模块（M3）

   根据M1的配置项编译M1的源码文件，得到字节码。但是编译形成的Runtime code和链上的Runtime code有一些区别，有一些参数需要实际链上信息才能确定

   因此有两个方案解决这个问题：
   - 1）记住所有编译形成的Runtime code中immutable variables的偏移量，并将其视为空白；将链上Runtime code对应偏移量的内容填进空白，直接确保二者immutable variables一致，但这不能做到完全验证的功能
   - 2）获取当时链上信息模拟执行Bytecode
4. 比对模块（M4）

   比对时一般要删除metadata，Blockscout采用一种方法，更改影响metadata的配置项信息，保持运行逻辑不变，通过观察bytecode中变化的部分来识别metadata
5. 数据存储模块（M5）

   完成比对后存储数据
6. 展示&API模块（M6）

   用户请求时响应

### 安全特征
1. 不可恢复性P1
   
   避免用字节码反汇编得到的源码直接通过验证

2. 一致性P2

   保证链上内容和用户上传内容的语义一致性

### 漏洞详情
1. 可以利用的编译器特性R1

   将Runtime code转化成内联汇编后构造fallback函数嵌入，fallback函数有空的函数签名。只在solc版本号≤0.4时可用
   
2. 未检查的模拟R2

   Sourcify采用模拟执行来验证Runtime code以处理不可变变量。如果攻击者构建了一个包装器（不是有效的Constructor Code），该包装器直接返回受害者的Runtime code（指定一个指向存有Runtime code的内存空间），那么这样的过程可能会破坏P1
   
3. 不完整的字节码验证R₃
   
   验证者可能不会要求用户提供附加在字节码后的参数的具体值，验证者可能会采用前缀匹配。这样的策略可能会被攻击者滥用，从而破坏 P1。这一过程可以通过利用松散内联汇编或组合抽象合约来完成。具体来说，抽象合约可以编译为空字节码；换句话说，一个抽象合约可以被视为任何合约的前缀。

4. 可替换的链上合约R4

   验证者依赖的客户端节点的状态和启用功能可能被攻击者利用，以替换已经在链上的合约；以及create2函数在同个地址部署合约的特性

5. 未验证的链接库R5

   验证时未考虑链接库中的具体实现，仅验证接口签名

6. 标签错误的字节码R6

   验证者会标记和有意跳过某些字段，以避免不必要的验证失败。然而，这样的有意跳过可能导致不一致问题。属于此范围的字段类型有两种，即元数据和链接库占位符。

7. 路径遍历风险R7

   solc 允许用户将源代码文件及其相应路径打包在一个 JSON 文件中，其中路径可以任意指定。如果验证者不严格验证路径，攻击者很可能利用此功能进行任意路径遍历

8. 信息披露不充分R8

   由用户的误解引入。攻击者可以将主合约和一个具有相同名称的假合约放在不同的路径下。因为只显示了合约名称，用户可能会误以为假合约是验证过的合约



    


